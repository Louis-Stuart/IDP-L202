#include <Adafruit_MotorShield.h>


Adafruit_MotorShield AFMS = Adafruit_MotorShield(); // Create the motor shield object with the default I2C address
Adafruit_DCMotor *leftMotor = AFMS.getMotor(1); //Set up motors
Adafruit_DCMotor *rightMotor = AFMS.getMotor(2);

//Define the port of each line sensor pin

int leftmostlinesensorPin = 0;
int leftlinesensorPin = 1;
int rightlinesensorPin = 2;
int rightmostlinesensorPin = 3;


//define constant

int lineSensors[4];
bool runOnce = false;
int lowSpeed = 0;
int highSpeed = 255;
int medSpeed = 70;
char forward = BACKWARD;
char backward = FORWARD;
int counter = 0;


//predefining navigation arrays

const char* startP1[5] = {"Str", "S", "L", "R", "X"};
const char* P1Green[4] = {"B", "L", "L", "X"};
const char* P1Red[5] = {"B", "R", "S", "R", "X"};
const char* greenP2[6] = {"Rot", "S", "S", "R", "R", "X"};
const char* redP2[7] = {"Rot", "S", "S", "S", "L", "R", "X"};
const char* P2Green[6] = {"B", "R", "L", "S", "S", "X"};
const char* P2Red[7] = {"B", "R", "R", "S", "S", "S", "X"};
const char* greenP3[6] = {"Rot", "S", "S", "S", "R", "X"};
const char* redP3[5] = {"Rot", "S", "S", "L", "X"};
const char* P3Green[6] = {"B", "R", "S", "S", "S", "X"};
const char* P3Red[5] = {"B", "L", "S", "S", "X"};
const char* greenP4[6] = {"Rot", "S", "R", "S", "R", "X"};
const char* redP4[5] = {"Rot", "S", "L", "L", "X"};
const char* redFinish[4] = {"Rot", "L", "L", "X"};
const char* greenFinish[5] = {"Rot", "R", "S", "R", "X"};


//predefine function
void lineSensorRead();
void lineFollowingStraight();
void stop(int t=0);
void straight(int speed=highSpeed, int t=0);
void reverse(int speed=highSpeed, int t=0);
void turn(int high, int low, bool left);
void turn_right();
void turn_left();
void navDecision(const char* route[]);
void actionTranslate(char action); 


void setup() {
  Serial.begin(9600); // Set up Serial library at 9600 bps
  if (!AFMS.begin()) {        
    Serial.println("Could not find Motor Shield. Check wiring.");
    while (1);
  }
  pinMode(leftmostlinesensorPin, INPUT); // Declare leftmostLED as input
  pinMode(leftlinesensorPin, INPUT); // Declare leftLED as input
  pinMode(rightlinesensorPin, INPUT); // Declare rightLED as input
  pinMode(rightmostlinesensorPin, INPUT); // Declare rightmostLED as input
}


//main
void loop() {
  //test function by adding it inside this loop
  lineFollowingStraight();
}

//Stop function cease the motor
void stop(int t=0) {
  leftMotor->setSpeed(0);
  rightMotor->setSpeed(0);
  //might need to run(release)
  delay(t);
}

//Straight function tells the motor to go straight regardless
void straight(int speed=highSpeed, int t=0) {
  leftMotor->run(forward);
  rightMotor->run(forward);
  leftMotor->setSpeed(speed);
  rightMotor->setSpeed(speed);
  delay(t);
}

//Reverse function tells the motor to run reversely 
void reverse(int speed=highSpeed, int t=0) {
  leftMotor->run(backward);
  rightMotor->run(backward);
  leftMotor->setSpeed(speed);
  rightMotor->setSpeed(speed);
  delay(t); 
}

//Turn function tells the motor to turn, the turning direction is specified by individual turn_left and turn_right functions
void turn(int high, int low, bool left) {
  leftMotor->run(forward);
  rightMotor->run(forward);
  if(left){
    leftMotor->setSpeed(high);
    rightMotor->setSpeed(low);
  }else{
    leftMotor->setSpeed(low);
    rightMotor->setSpeed(high);
  }
}

void turn_left(int high, int low) {
  turn(high,low,true);
}

void turn_right(int high, int low) {
  turn(high,low,false);
}

//It reads the states of four line sensors continuously
void lineSensorRead(){
  lineSensors[0] = digitalRead(leftmostlinesensorPin);
  lineSensors[1] = digitalRead(leftlinesensorPin);
  lineSensors[2] = digitalRead(rightlinesensorPin);
  lineSensors[3] = digitalRead(rightmostlinesensorPin);
}

//This function includes the functionality of straight line following, turning at single T junctions and double T junctions
void lineFollowingStraight() {
  lineSensorRead();
  Serial.print(lineSensors[0]);
  Serial.print(lineSensors[1]);
  Serial.print(lineSensors[2]);
  Serial.println(lineSensors[3]);
  // when line sensing based on the two middle sensors picking up white, the bot goes straight 
  if (lineSensors[1] && lineSensors[2]){
    // sensor0=0, sensor1=1, sensor2=1, sensor3=0
    straight();
  }

  // correction for staying on the line
  if (lineSensors[1] && !lineSensors[2]) {
    // sensor0=0, sensor1=1, sensor2=0, sensor3=0
    turn_right(highSpeed, medSpeed);
  }
  
  // correction for staying on the line
  if (!lineSensors[1] && lineSensors[2]) {
    // sensor0=0, sensor1=0, sensor2=1, sensor3=0
    turn_left(highSpeed, medSpeed);
  }
  /*
  // in case of a double t junction so all four see white
  if (lineSensors[0] && lineSensors[1] && lineSensors[2] && lineSensors[3]){
    // sensor0=1, sensor1=1, sensor2=1, sensor3=1
    //consult the navigation location
  }
*/

  // in case of a single right t junction 
  if (!lineSensors[0] && lineSensors[1] && lineSensors[2] && lineSensors[3]){
    // sensor0=0, sensor1=1, sensor2=1, sensor3=1
    turn_left(150, lowSpeed);
    delay(1000);
    //turn left for a moment to let the middle two sensors go off the line 
    while (!lineSensors[1] && !lineSensors[2]) {
      //the bot will then turn right until the middle two picks the white line again at which time it should goes straight 
      turn_left(150, lowSpeed);
    }
  }

  // in case of a single left t junction 
  if (lineSensors[0] && lineSensors[1] && lineSensors[2] && !lineSensors[3]){
    // sensor0=1, sensor1=1, sensor2=1, sensor3=0
    turn_right(150, lowSpeed);
    delay(1000);
    //turn right for a moment to let the middle two sensors go off the line
    while (!lineSensors[1] && !lineSensors[2]) {
      //the bot will then turn left until the middle two picks the white line again at which time it should goes straight
      turn_right(150, lowSpeed);
    }
  }

}

// This two functions takes char arrays of routes as input ,analyzes the meaning of individual element and takes actions
void navDecision(const char* route[]) {
    lineSensorRead();
    int routeSize = sizeof(route) / sizeof(route[0]);
    for (int i = 0; i < routeSize; ++i) {
        actionTranslate(route[i]);
    }
}

void actionTranslate(char action) {
  //Str is for travelling straight for a given time, not line following
    if (action == 'Str') {
      straight(highSpeed, 2000);
    }
    //S is for going straight using line following code, but this is only for when you're ignoring a turn to go straight
    if (action == 'S') {
      if (!lineSensors[0] && lineSensors[1] && lineSensors[2] && !lineSensors[3]){
        // sensor0=0, sensor1=1, sensor2=1, sensor3=0
        straight();
      }
      if (!lineSensors[0] && lineSensors[0] && lineSensors[0] && !lineSensors[3]){
        // sensor0=0, sensor1=1, sensor2=1, sensor3=0
        straight(medSpeed, 2000);
      }
      if (!lineSensors[0] &&  lineSensors[3]){
        // sensor0=0, sensor3=1
        stop(1000);
      }
      if (lineSensors[0] &&  !lineSensors[3]){
        // sensor0=1, sensor3=0
        stop(1000);
      }
      if (lineSensors[0] && lineSensors[3]){
        // sensor0=1, sensor3=1
        stop(1000);
      }
    }
    //L is for turning left
    if (action == 'L') {
      turn_left();
      delay(1000);
      if (!lineSensors[0] && lineSensors[1] && lineSensors[2] && !lineSensors[3]){
        // sensor0=0, sensor1=1, sensor2=1, sensor3=0
        stop(1000);
      }
    }
    //R is for turning right
    if (action == 'R') {
      turn_right();
      if (!lineSensors[0] && lineSensors[1] && lineSensors[2] && !lineSensors[3]){
        // sensor0=0, sensor1=1, sensor2=1, sensor3=0
        stop(1000);
      }
    }
    //B is for back, so reversing
    if (action == 'B') {
      reverse();
      if (lineSensors[0] && lineSensors[1] && lineSensors[2] && lineSensors[3]) {
        stop();
      }
    }
    //Rot is for a 180 degree rotation, so for leaving the bays exclusively
    if (action == 'Rot') {
      turn_right();
      if (!lineSensors[0] && lineSensors[1] && lineSensors[2] && !lineSensors[3]) {
        stop();
      }
    }  
    if (action == 'X') {
      stop();
    }
  }
